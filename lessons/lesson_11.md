# Урок 11. Управление потоком выполнения

## Оператор конвейера (pipe)

Оператор pipe `|>` является одной из отличительных особенностей языка программирования Elixir, позволяющий улучшить читаемость и структуру кода. 
Он позволяет передать результат одной функции в качестве аргумента другой. Хорошим примером может являться аналогичный оператор конвеера `|` в unix-системах.

Пример:
```elixir
third(second(first()))
# через оператор pipe:
first() |> second() |> third()
```
Оператор, обозначаемый как `|>`, принимает результат одного выражения и передает его в качестве первого аргумента следующему. 
Это позволяет создавать цепочки выполнения, что способствует формированию лаконичного и понятного кода.

Рассмотрим, как можно организовать код для реализации собственного DQL (Data Query Language), чтобы он был читаемым, простым и открытым для расширения.
```elixir
build_query()
|> add_select(:count)
|> add_select(:name)
|> group_by(:age)
|> limit(5)
|> order_by(:name)
|> build()
|> execute!()
```
Для начала, мы можем использовать оператор `pipe`, который позволяет выстраивать цепочку вызовов методов. Это делает код более структурированным и легким для понимания.
Первым шагом будет метод `build_query`, который создаст пустую структуру. Эта структура будет наполняться данными по мере прохождения через цепочку вызовов.
Здесь каждая функция первым аргументом принимает на вход `query` а вторым дополнительные параметры.
Затем, с помощью метода `build`, мы преобразуем структуру в SQL-запрос, соответствующий конечной системе управления базами данных (СУБД). Наконец, мы выполним запрос с помощью метода `execute!`.
Таким образом, подход с использованием цепочки методов не только упрощает чтение кода, но и предоставляет возможность легко добавлять новые функции или изменять существующие, не нарушая логическую структуру работы.

## Конструкция if else

Синтаксис конструкции `if` выглядит следующим образом:
```elixir
if условие do
  # код, выполняемый, если условие истинно
else
  # код, выполняемый, если условие ложно
end
```

Для простых условий, где не требуется ветвление, можно использовать конструкцию if без else:
```elixir
if условие do
  # код, выполняемый, если условие истинно
end
```

Результат выполнения можно присвоить переменной:
```elixir
result = 
  if condition do
    "condition is true"
  else
    "condition is false"
  end
```

Конструкция `unless` аналогична `if`, но работает наоборот.

## Конструкция case

Синтаксис конструкции `case` выглядит следующим образом:
```elixir
case выражение do
  образец1 -> действие1
  образец2 -> действие2
  ...
  образецN -> действиеN
end
```

Выражение - это значение, которое сопоставляется с заданными образцами.
Конструкция `case` работает по принципу "первый соответствующий образец". 
Это означает, что Elixir последовательно проверяет каждое выражение и выполняет первое действие, для которого найдено соответствие.

Кроме сопоставления с образцом в конструкции можно использовать охранные выражения `guards`:
```elixir
case value do
  {:ok, id} when is_integer(id) -> "получено число"
  {:ok, str} when is_binary(str) -> "получена строка"
  _any -> "любой другой результат"
end
```
Если ни один из образцов не совпадет, возникнет исключение `CaseClauseError`. Поэтому обычно в последней строке рекомендуется сопоставлять все оставшиеся значения.

## Конструкция cond

Когда нужно проверять условия, а не значения, можно использовать конструкцию `cond/1`:
```elixir
cond do
  условие1 -> действие1
  условие2 -> действие2
  ...
  true -> действиеN
end
```
Конструкция cond проверяет каждое условие по порядку, начиная с верхнего. Как только одно из условий возвращает `true`, выполняется соответствующее действие, и остальные условия игнорируются.

Пример:
```elixir
cond do
  age < 0 -> "Некорректный возраст"
  age < 13 -> "Ребёнок"
  age < 20 -> "Подросток"
  age < 65 -> "Взрослый"
  age < 120 -> "Пожилой"
  true -> "неверный формат"
end
```
Если ни одно из условий не сработает, будет выдано исключение `CondClauseError`. Поэтому обычно в последней строке добавляют условие `true`, чтобы выполнить действие, если все предыдущие условия не подошли.

## Конструкция with

Конструкция `with` представляет собой более продвинутый вариант управления, который позволяет проверять ответы функций на каждом этапе. Она использует сопоставление и охранные выражения, а также умеет обрабатывать возможные ошибки.
Синтаксис конструкции `with` выглядит следующим образом:
```elixir
with образец1 <- действие1,
  образец2 -> действие2,
  ...
  образецN -> действиеN do
    выполнение
  else
    ошибка1 -> завершение1
    ошибка2 -> завершение2
    ...
    ошибкаN -> завершениеN
  end
end
```
В данном контексте под ошибкой понимается любой ответ на "действие", который не прошел сопоставление.
Важно отметить, что в синтаксисе конструкция `else` не является обязательной. Если вы не укажете блок else, конструкция `with` вернет первый же несопоставленный ответ.
Например:
```elixir
with {:ok, user} <- get_user(),
     {:ok, post} <- get_post(user.id) do
       {:ok, post}
end
```
Если функция `get_user()` вернет `{:error, "not found"}`, выполнение прервется на первом шаге, так как сопоставление не произошло.
Если нужно обработать ответы с ошибкой, мы можем добавить сопоставление на этот кортеж в блоке `else` и изменить его по своему усмотрению. 
В результате мы сможем получить только текстовое сообщение в ответе:
```elixir
with {:ok, user} <- get_user(),
     {:ok, post} <- get_post(user.id) do
       {:ok, post}
else
  {:error, message} -> "Поиск вернул ошибку #{message}"
end
```

Использование конструкции with позволяет избежать избыточной вложенности, которая часто возникает при выполнении множества операций, каждая из которых может вызвать ошибку. 
Централизованная обработка ошибок делает код более чистым и понятным, обеспечивая возможность учесть все негативные сценарии.

## Задание

> **ЗАДАНИЕ**. Реализовать модуль `AgeHelper` в файле [AgeHelper](../lib/age_helper.ex).
> В модуле требуется реализовать единственную функцию `validate/1`, которая принимает один аргумент на вход и возвращает следующие ответы:
> - `{:error, "not_integer"}` если присланное значение не является числом.
> - `{:error, "negative_integer"}` если присланное значение меньше нуля.
> - `{:ok, "детский"}` если присланное значение от 0 до 17 включительно.
> - `{:ok, "взрослый"}` если присланное значение равно 18 и больше.
> Конструкцию можно выбрать любую.

> **Самопроверка**. Запустить команду `make verify` для проверки кода.
> Запустить тест модуля: `mix test test/age_hepler_test.exs`
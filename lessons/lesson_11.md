# Урок 11. Управление потоком выполнения

## Оператор конвейера (pipe)

Оператор pipe `|>` является одной из отличительных особенностей языка программирования Elixir, позволяющий улучшить читаемость и структуру кода. 
Он позволяет передать результат одной функции в качестве аргумента другой. Хорошим примером может являться аналогичный оператор конвеера `|` в unix-системах.

Пример:
```elixir
third(second(first()))
# через оператор pipe:
first() |> second() |> third()
```
Оператор, обозначаемый как `|>`, принимает результат одного выражения и передает его в качестве первого аргумента следующему. 
Это позволяет создавать цепочки выполнения, что способствует формированию лаконичного и понятного кода.

Рассмотрим, как можно организовать код для реализации собственного DQL (Data Query Language), чтобы он был читаемым, простым и открытым для расширения.
```elixir
build_query()
|> add_select(:count)
|> add_select(:name)
|> group_by(:age)
|> limit(5)
|> order_by(:name)
|> build()
|> execute!()
```
Для начала, мы можем использовать оператор `pipe`, который позволяет выстраивать цепочку вызовов методов. Это делает код более структурированным и легким для понимания.
Первым шагом будет метод `build_query`, который создаст пустую структуру. Эта структура будет наполняться данными по мере прохождения через цепочку вызовов.
Здесь каждая функция первым аргументом принимает на вход `query` а вторым дополнительные параметры.
Затем, с помощью метода `build`, мы преобразуем структуру в SQL-запрос, соответствующий конечной системе управления базами данных (СУБД). Наконец, мы выполним запрос с помощью метода `execute!`.
Таким образом, подход с использованием цепочки методов не только упрощает чтение кода, но и предоставляет возможность легко добавлять новые функции или изменять существующие, не нарушая логическую структуру работы.

## Конструкция if else

Синтаксис конструкции `if` выглядит следующим образом:
```elixir
if условие do
  # код, выполняемый, если условие истинно
else
  # код, выполняемый, если условие ложно
end
```

Для простых условий, где не требуется ветвление, можно использовать конструкцию if без else:
```elixir
if условие do
  # код, выполняемый, если условие истинно
end
```

Результат выполнения можно присвоить переменной:
```elixir
result = 
  if condition do
    "condition is true"
  else
    "condition is false"
  end
```

Конструкция `unless` аналогична `if`, но работает наоборот.

## Конструкция case

Синтаксис конструкции `case` выглядит следующим образом:
```elixir
case выражение do
  образец1 -> действие1
  образец2 -> действие2
  ...
  образецN -> действиеN
end
```

Выражение - это значение, которое сопоставляется с заданными образцами.
Конструкция `case` работает по принципу "первый соответствующий образец". 
Это означает, что Elixir последовательно проверяет каждое выражение и выполняет первое действие, для которого найдено соответствие.

Кроме сопоставления с образцом в конструкции можно использовать охранные выражения `guards`:
```elixir
case value do
  {:ok, id} when is_integer(id) -> "получено число"
  {:ok, str} when is_binary(str) -> "получена строка"
  _any -> "любой другой результат"
end
```
Если ни один из образцов не совпадет, возникнет исключение `CaseClauseError`. Поэтому обычно в последней строке рекомендуется сопоставлять все оставшиеся значения.

## Конструкция cond

Когда нужно проверять условия, а не значения, можно использовать конструкцию `cond/1`:
```elixir
cond do
  условие1 -> действие1
  условие2 -> действие2
  ...
  true -> действиеN
end
```
Конструкция cond проверяет каждое условие по порядку, начиная с верхнего. Как только одно из условий возвращает `true`, выполняется соответствующее действие, и остальные условия игнорируются.

Пример:
```elixir
cond do
  age < 0 -> "Некорректный возраст"
  age < 13 -> "Ребёнок"
  age < 20 -> "Подросток"
  age < 65 -> "Взрослый"
  age < 120 -> "Пожилой"
  true -> "неверный формат"
end
```
Если ни одно из условий не сработает, будет выдано исключение `CondClauseError`. Поэтому обычно в последней строке добавляют условие `true`, чтобы выполнить действие, если все предыдущие условия не подошли.

## Конструкция with

(TODO)
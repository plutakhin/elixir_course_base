# Урок 6. Работа с массивами

Другой важнейший тип представленный в коллекциях Elixir это ассоциативный массив.

## Теория

В Elixir, ассоциативный массив (или словарь) - это структура данных, которая позволяет хранить пары ключ-значение, с возможностью быстрого получения информации по ключу.
Ключи в ассоциативном массиве должны быть уникальными и могут быть любого типа, в отличие от ключевых списков. При этом порядок следования не важен.
Значения также могут быть любого типа.
Ассоциативный массив объявляется с помощью синтаксиса `%{}`

Вот пример создания ассоциативного массива к ключами строками:

```elixir
iex(1)> map = %{"a" => 1, "b" => 2}
%{"a" => 1, "b" => 2}
iex(2)> map["a"]
1
iex(3)> map["b"]
2
```

Вот пример создания ассоциативного массива с ключами атомами:

```elixir
iex(4)> map = %{a: 1, b: 2}
%{a: 1, b: 2}
iex(5)> map[:a]
1
iex(6)> map[:b]
2
```

И синтаксический сахар для частного случая, где ключи являются атомами:

```elixir
iex(7)> map = %{a: 1, b: 2}
%{a: 1, b: 2}
iex(8)> map.a
1
iex(9)> map.b
2
```

**ВАЖНО**. Создать массив с разными ключами можно, но крайне не рекомендуется. При попытке доступа к ключу с неправильным типом - наиболее часто встречающаяся ошибка!

Как и со списками, у массивов тоже есть свой особенный синтаксис для обновления:

```elixir
iex(12)> map = %{a: 1, b: 2}
%{a: 1, b: 2}
iex(13)> %{map | a: 3}
%{a: 3, b: 2}
```
Такой синтаксис работает только для обновления существующих ключей в ассоциативных массивах! Если указанного ключа нет, возникнет исключение KeyError.
На практике чаще всего используют функции модуля [Map](https://hexdocs.pm/elixir/Map.html) по имени метода которого проще понять, какое действие с массивом определено.

## Спецификация модуля Map

 - Map.get/2 - доступ к значению по ключу вернет nil если ключа нет.
 - Map.get/3 - доступ к значению по ключу с указанием default значения если ключа нет.
 - Map.fetch/2 - доступ к значению по ключу, вернет :error если ключа нет.
 - Map.fetch!/2 - доступ к значению по ключу, вызовет исключение если ключа нет.
 - Map.has_key?/2 - проверка, существует ли ключ.
 - Map.put/3 - положит новое значение по ключу.
 - Map.put_new/3 - положит новое значение по ключу, если такого ключа нет.
 - Map.delete/2 - вернет новый массив без указанного ключа.
 - Map.drop/2 - тоже что delete, только можно передать список ключей.
 - Map.take/2 - вернет массив с указанным списком ключей.
 - Map.merge/2 - объединение массивов.

Полный список тут [Map.html#functions](https://hexdocs.pm/elixir/Map.html#functions).

## Расширенные способы доступа 

Массивы могут быть не только плоскими, но и с огромной глубиной вложения. 
Для доступа к нижнему ключу в дереве можно использовать разный синтаксис, но результат может отличаться, если по пути "следования" будет отсутствовать один из элементов.

Например:
```elixir
iex(1)> map = %{a: %{b: %{c: 1}}}
%{a: %{b: %{c: 1}}}
iex(2)> map[:a][:b][:c]
1
iex(3)> map.a.b.c
1
```

Второй вариант работает только для ключей атомов, и только если все значения присутствуют в дереве.
```elixir
iex(4)> map.a.x.c
** (KeyError) key :x not found in: %{b: %{c: 1}}
iex:4: (file)
iex(4)> map[:a][:x][:c]
nil
```

Предпочтительней использовать безопасный метод [get_in](https://hexdocs.pm/elixir/Kernel.html#get_in/2) модуля Kernel:

```elixir
iex(5)> get_in(map, [:a, :b, :c])
1
iex(6)> get_in(map, [:a, :x, :c])
nil
```
Он работает как с ключами атомами, так и со строками.
Для вставки есть аналогичный метод [put_in](https://hexdocs.pm/elixir/Kernel.html#put_in/2).

## Задание

> **ЗАДАНИЕ**. Добавить реализацию всех методов модуля [App.MapHelper](../lib/map_helper.ex).

Модуль [App.MapHelper](../lib/map_helper.ex) должен содержать следующий набор публичных методов:
- init/0 Метод инициализации пустого массива
- add/3 Метод принимает на вход массив, ключ и значение и добавляет его в список, если такой ключ есть то заменяет его значение.
- remove/2 Метод удаляет значение из массива по его ключу, если ключа нет, возвращает исходный массив.
- count/1 Метод вычисляет количество пар ключей в массиве 

> **Самопроверка**. Запустить команду `make verify` для проверки кода.
> Запустить тест модуля: `mix test test/map_helper_test.exs`

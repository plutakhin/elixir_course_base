# Урок 4. Модули и функции

## Определение модуля

Модуль в Elixir — это контейнер для функций и других модулей, который помогает логически организовать код. 
Каждый модуль может включать в себя различные элементы, такие как функции, структуры данных, константы и даже другие модули.

Модули в Elixir определяются с помощью ключевого слова`defmodule`:
```elixir
defmodule App do
end
```

Обычно каждый модуль соответствует одному файлу. Имя этого файла формируется из имени модуля, переводимого из стиля CamelCase в snake_case. 
Модули могут располагаться в поддиректориях проекта, и в этом случае наименование модуля разделяется точками.
Файл модуля `lib/base_helpers/my_module.ex`:
```elixir
defmodule BaseHelpers.MyModule do
end
```

Чтобы открыть наш модуль в интерактивной оболочке нужно указать его путь `iex lib/app.ex`. 
Если мы внесем изменения в модуле, чтобы перекомпилировать его, необходимо вызвать хелпер `r App`:

```bash
% iex lib/app.ex
iex(1)> App.hello
:world
iex(2)> r App
    warning: redefining module App (current version defined in memory)
    │
  1 │ defmodule App do
    │ ~~~~~~~~~~~~~~~~
    │
    └─ lib/app.ex:1: App (module)

{:reloaded, [App]}
iex(3)> App.hello
"hello world"
```

Если мы запустили интерактивный режим с помощью команды `iex -S mix`, то можем перекомпилировать все измененные модули, используя вспомогательную функцию `recompile`.
```bash
% iex -S mix
iex(1)> App.hello
:world
iex(2)> recompile
Compiling 1 file (.ex)
:ok
iex(3)> App.hello
"hello world"
```

## Именованные функции

Внутри модуля мы можем определить публичную функцию с помощью ключевого слова `def`, а приватную — используя `defp`. 
Публичные функции, определенные через `def`, можно вызывать из других модулей или оболочки `iex`. 
Приватные функции, созданные с помощью `defp`, могут быть вызваны только внутри самого модуля.
Важно помнить что приватные функции не могут быть напрямую покрыты моками в тестах.

Пример:
```elixir
defmodule App do
  def hello() do
    "public"
  end
  
  defp internal() do
    "private"
  end
end

iex(1)> App.hello()
"public"
iex(2)> App.internal()
** (UndefinedFunctionError) function App.internal/0 is undefined or private
App.internal()
iex:2: (file)
```
В данном примере обозначение `App.internal/0` называется арностью функции, тоесть это количество аргументов, которые она принимает.
Даже конструкции тоже имеют свою арность. Например конкатенация строк `<>` имеет арность 2, поэтому если вы хотите получить помощь по данной конструкции нужно вызывать хелпер с указанием арности: `h <>/2`.
Здесь и далее при указании функций модулей всегда будет указана ее арность, это важный аспект патерн-матчинга, с которым познакомимся позднее.
Функции можно вызывать и определять без скобок если их арность /0, но это не принято делать, из-за соображения читаемости кода.

Функции могут иметь одинаковые наименования, но разную арность:
```elixir
defmodule App do
  def hello(), do: "hello world"
  def hello(name), do: "hello " <> name
end
```
В данном примере приведена короткая форма записи функции, такой способ удобен когда тело функции умещается в одну строку.

В отличии например от Ruby, в Elixir нет управляющей конструкции `return` которая может прервать выполнение функции и вернуть результат. 
Результатом будет являться последнее вычесленное выражение, либо `nil` если тело функции пустое.  

## Аргументы в функциях

Аргументы в функциях могут принимать значения по умолчанию, при этом есть соглашение рассполагать такие аргументы в конце списка:
```elixir
defmodule App do
  def concat(a, b \\ "!") do
    a <> b
  end
end

iex(1)> App.concat("hello")
"hello!"
iex(2)> App.concat("hello", " world")
"hello world"
```

Аргументы которые не используются в функциях принято обозначать символом подчеркивания `_` перед именем:
```elixir
defmodule App do
  def hello(name, _opts) do
   "hello " <> name
  end
end
```

## Атрибуты модулей

Атрибуты модулей или как их еще называют константами, определяются через символ `@` перед их наименованием:
```elixir
defmodule App do
  @title "hello world"
  def hello() do
   @title
  end
end
```
При этом константы закрыты в области видимости самого модуля, для того чтобы иметь доступ можно определить функцию "хелпер", которая вернет данное значение:
```elixir
defmodule App do
  @title "hello world"
  def title(), do: @title
end
```
Стоит учитывать что есть несколько зарезервированных названий атрибутов в Elixir, такие как: `@moduledoc`, `@spec`, `@doc`, `@derive`, `@behaviour`, `@compile` - с ними познакомимся позднее.

## Алиасы

Для удобства вызова модулей можно использовать сокращенные наименования, в том числе определять произвольное имена через опцию `as:`:
```elixir
defmodule App do
  alias Name.To.Long.Mod
  alias Can.Be.Aliased.Me, as: MyCustomName
  
  def test() do
    Mod.foo() + MyCustomName.bar()
  end
end
```
Алиасы в том числе позволяют избежать конфликтов в случае если используются одинако именованные модули.

## Импорт функций

Еще один способ вызова функций другого модуля без создания алиасов это импорт функции.
Можно выполнить как полный импорт всех публичных функций, так и с указанием конкретных, при этом нужно лишь указать арность функции:

```elixir
defmodule App do
  import IntegerParser # импортирует все функции
  import Kernel, except: [div: 2, max: 2] # импортирует все кроме перечисленные функции
  import Utils, only: [is_empty: 1, is_blank: 1] # импортирует только перечисленные функции
  
  def value_not_present(string) do
    value = IntegerParser.parse(string)
    is_empty(value) and is_blank(value)
  end
end
```

Использование `use` и `require` будут рассмотрены позднее.

## Анонимные функции

Анонимную функцию в Elixir можно задать с использованием конструкции `fn ... end`, и вызвать через точку:

```elixir
iex(1)> function_variable = fn n -> n + 1 end
#Function<42.39164016/1 in :erl_eval.expr/6>
iex(2)> function_variable.(1)
2
```
Анонимные функции можно создавать с помощью сокращения `&`.
Первый `&` объявляет начало выражения, а `&1`, `&2` и т.д. объявляет аргументы функции:

```elixir
iex(1)> sum = &(&1 + &2)
&:erlang.+/2
iex(2)> sum.(1, 2)
3
```

Одним из полезных применений анонимных функций является их передача в качестве аргументов другим функциям, особенно в контексте работы с коллекциями.
Здесь приведены 3 рабочих способа вызова анонимной функции:
```elixir
iex(1)> square = &(&1 * &1)
iex(2)> Enum.map([1, 2, 3], square)
[1, 4, 9]
iex(3)> Enum.map([1, 2, 3], &(&1 * &1))
[1, 4, 9]
iex(4)> Enum.map([1, 2, 3], fn v -> v * v end)
[1, 4, 9]
```
Передача неанонимных функций также осуществляется с использованием символа `&`, дополнительно указывается арность функции:
```elixir
iex(1)> Enum.map(["a", "b", "c"], &String.to_atom/1)
[:a, :b, :c]
```
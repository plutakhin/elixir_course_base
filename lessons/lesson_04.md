# Урок 4. Модули и функции

## Определение модуля

Модуль в Elixir — это контейнер для функций и других модулей, который помогает логически организовать код. 
Каждый модуль может включать в себя различные элементы, такие как функции, структуры данных, константы и даже другие модули.

Модули в Elixir определяются с помощью ключевого слова`defmodule`:
```elixir
defmodule App do
end
```

Обычно каждый модуль соответствует одному файлу. Имя этого файла формируется из имени модуля, переводимого из стиля CamelCase в snake_case. 
Модули могут располагаться в поддиректориях проекта, и в этом случае наименование модуля разделяется точками.
Файл модуля `lib/base_helpers/my_module.ex`:
```elixir
defmodule BaseHelpers.MyModule do
end
```

Чтобы открыть наш модуль в интерактивной оболочке нужно указать его путь `iex lib/app.ex`. 
Если мы внесем изменения в модуле, чтобы перекомпилировать его, необходимо вызвать хелпер `r App`:

```bash
% iex lib/app.ex
iex(1)> App.hello
:world
iex(2)> r App
    warning: redefining module App (current version defined in memory)
    │
  1 │ defmodule App do
    │ ~~~~~~~~~~~~~~~~
    │
    └─ lib/app.ex:1: App (module)

{:reloaded, [App]}
iex(3)> App.hello
"hello world"
```

Если мы запустили интерактивный режим с помощью команды `iex -S mix`, то можем перекомпилировать все измененные модули, используя вспомогательную функцию `recompile`.
```bash
% iex -S mix
iex(1)> App.hello
:world
iex(2)> recompile
Compiling 1 file (.ex)
:ok
iex(3)> App.hello
"hello world"
```

## Именованные функции


Внутри модуля мы можем определить публичную функцию с помощью ключевого слова `def`, а приватную — используя `defp`. 
Публичные функции, определенные через `def`, можно вызывать из других модулей или оболочки `iex`. 
Приватные функции, созданные с помощью `defp`, могут быть вызваны только внутри самого модуля.
Важно помнить что приватные функции не могут быть напрямую покрыты моками в тестах.

Пример:
```elixir
defmodule App do
  def hello() do
    "public"
  end
  
  defp internal() do
    "private"
  end
end

iex(1)> App.hello()
"public"
iex(2)> App.internal()
** (UndefinedFunctionError) function App.internal/0 is undefined or private
App.internal()
iex:2: (file)
```
В данном примере обозначение `App.internal/0` называется арностью функции, тоесть это количество аргументов, которые она принимает.
Даже конструкции тоже имеют свою арность. Например конкатенация строк `<>` имеет арность 2, поэтому если вы хотите получить помощь по данной конструкции нужно вызывать хелпер с указанием арности: `h <>/2`.
Здесь и далее при указании функций модулей всегда будет указана ее арность, это важный аспект патерн-матчинга, с которым познакомимся позднее.

Функции могут иметь одинаковые наименования, но разную арность:
```elixir
defmodule App do
  def hello(), do: "hello world"
  def hello(name), do: "hello " <> name
end
```
В данном примере приведена короткая форма записи функции, такой способ удобен когда тело функции умещается в одну строку.

## Аргументы в функциях

Аргументы в функциях могут принимать значения по умолчанию, при этом есть соглашение рассполагать такие аргументы в конце списка:
```elixir
defmodule App do
  def concat(a, b \\ "!") do
    a <> b
  end
end

iex(1)> App.concat("hello")
"hello!"
iex(2)> App.concat("hello", " world")
"hello world"
```

Аргументы которые не используются в функциях принято обозначать символом подчеркивания `_` перед именем:
```elixir
defmodule App do
  def hello(name, _opts) do
   "hello " <> name
  end
end
```

## Атрибуты модулей

Атрибуты модулей или как их еще называют константами, определяются через символ `@` перед их наименованием:
```elixir
defmodule App do
  @title "hello world"
  def hello() do
   @title
  end
end
```
При этом константы закрыты в области видимости самого модуля, для того чтобы иметь доступ можно определить функцию "хелпер", которая вернет данное значение:
```elixir
defmodule App do
  @title "hello world"
  def title(), do: @title
end
```
Стоит учитывать что есть несколько зарезервированных названий атрибутов в Elixir, такие как: `@moduledoc`, `@spec`, `@doc`, `@derive`, `@behaviour`, `@compile` - с ними познакомимся позднее.


# Урок 8. Сопоставление с образцом

## Теория

Pattern Matching (сопоставление с образцом) в языке программирования Elixir представляет собой механизм, позволяющий сопоставлять структуры данных (шаблоны), извлекая из них информацию и выполняя соответствующие операции.

Простой пример, присвоения в Elixir работает как сопоставление с образцом:

```elixir
iex(1)> a = 12345
12345
iex(2)> a
12345
```

Оператор `=` называется оператором сопоставления (match operator). Если шаблон соответствует значению, то сопоставление происходит успешно, и переменная `a` связывается со значением.

Сопоставлять можно несколько значений сразу:
```elixir
iex(3)> {a, b} = {1, 2}
{1, 2}
iex(4)> a
1
iex(5)> b
2
```

Если шаблон не соответствует структуре, то будет выброшено исключение `MatchError`:
```elixir
iex(6)> 2 = 5
** (MatchError) no match of right hand side value: 5
iex(6)> {a, b} = {1, 2, 3}
** (MatchError) no match of right hand side value: {1, 2, 3}
```

Более интересно рассмотреть варианты сопоставления, когда мы хотим извлечь из структуры часть информации:

**Случай №1**
Для разбора списка
```elixir
iex(7)> [head | tail] = [1, 2, 3]
[1, 2, 3]
iex(8)> head
1
iex(9)> tail
[2, 3]
```

**Случай №2**
Для разбора строки
```elixir
iex(10)> "name:" <> id  = "name:123"
"name:123"
iex(11)> id
"123"
```

**Случай №3**
Если переменная встречается два раза, то значения в этих местах должны быть одинаковыми:
```elixir
iex(12)> {a, a, 42} = {10, 10, 42}
{10, 10, 42}
iex(13)> {a, a, 42} = {10, 20, 42}
** (MatchError) no match of right hand side value: {10, 20, 42}
```

Исправить ситуацию можно используя символ подчеркивания:
```elixir
iex(14)> {a, _, 42} = {10, 20, 42}
{10, 20, 42}
iex(15)> a
10
```

Еще один нюанс заключается в том, что если мы хотим сопоставить значение в переменной для проверки соответствия шаблону, то используется специальный pin оператор `^`:
```elixir
iex(20)> animal = :cat
:cat
iex(21)> {^animal, "Tom"} = {:cat, "Tom"}
{:cat, "Tom"}
iex(22)> {^animal, "Tihon"} = {:dog, "Tihon"}
** (MatchError) no match of right hand side value: {:dog, "Tihon"}
```

### Сопоставление с массивов

В шаблоне не нужно перечислять все ключи, какие есть в словаре. Мы указываем только те ключи, которые нам нужны:
```elixir
iex(1)> map = %{a: 1, b: 2, c: 3}
%{c: 3, b: 2, a: 1}
iex(2)> %{a: value} = map
%{c: 3, b: 2, a: 1}
iex(3)> value
1
```

Если в словаре нет нужного ключа, то возникает исключение MatchError:
```elixir
iex(4)> map = %{a: 1, b: 2, c: 3}
%{c: 3, b: 2, a: 1}
iex(5)> %{d: value} = map
** (MatchError) no match of right hand side value: %{c: 3, b: 2, a: 1}
```

Если ключи не являются атомами, то синтаксис отличается:
```elixir
iex(1)> map = %{"a" => 1, "b" => 2, "c" => 3}
%{"a" => 1, "b" => 2, "c" => 3}
iex(2)> %{"a" => value} = map
%{"a" => 1, "b" => 2, "c" => 3}
iex(3)> value
1
```

### Особенности при сопоставлении пустого массива

Сопоставление с образцом часто используется для определения поведения функции в зависимости от содержимого переданного аргумента. 
Этот подход помогает оптимизировать код и разнообразить логику работы функции.

Рассмотрим пример, модуль для подсчета значений в списке:
```elixir
defmodule App do
  def count([] = _list), do: 0
  def count(list), do: Enum.count(list)
end
```
Такой метод будет работать корректно даже для пустого списка. 
Однако, если мы хотим проверить, что передан пустой массив, просто использовать сопоставление с `%{}` делать нельзя:
```elixir
defmodule App do
  # НЕПРАВИЛЬНО, каждый вызов функции будет обработан в первой функции
  def count(%{} = _map), do: 0
  def count(map), do: map |> Map.keys() |> Enum.count()
end
```

Данное поведение легко проверить, если переданный аргумент сопоставляется с шаблоном. В этом случае вызов функции пройдет успешно:
```elixir
iex(1)> %{} = %{a: 1}
%{a: 1}
iex(2)> [] = [1, 2, 3]
** (MatchError) no match of right hand side value: [1, 2, 3]
end
```

Теперь, зная особенности сопоставления с массивом, можно переписать модуль так, чтобы ограничить обработку пустого массива:
```elixir
defmodule App do
  def count(map) when map == %{}, do: 0
  def count(map), do: map |> Map.keys() |> Enum.count()
end
```

## Задание

> **ЗАДАНИЕ**. Переписать методы в модуле [PatternMatch](../lib/pattern_match.ex) используя подсказки над методом.

> **Самопроверка**. Запустить команду `make verify` для проверки кода.
> Запустить тест модуля: `mix test test/pattern_match_test.exs`

## Дополнительные материалы

https://elixirschool.com/ru/lessons/basics/pattern_matching
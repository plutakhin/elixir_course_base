# Урок 10. Исключения

В Elixir, как и в других языках программирования, исключения возникают как во время компиляции так и в момент выполнения программы.

Например если в коде реализована структура с обязательным полем `title`, а вы забудете указать это поле, то такое приложение не скомпилируется и будет выброшено исключение:
```bash
mix compile

== Compilation error in file lib/struct.ex ==
** (ArgumentError) the following keys must also be given when building struct App.Struct: [:title]
```
Такие исключения еще до запуска приложения позволяют правильно организовать код.

В момент выполнения так же могут быть выброшены исключения, например вызов несуществующей функции модуля:
```elixir
iex(1)> App.Struct.bad_function_name()
** (UndefinedFunctionError) function App.Struct.bad_function_name/0 is undefined or private
    (app 0.1.0) App.Struct.bad_function_name()
    iex:1: (file)
```

##  Перехват исключений

Elixir предоставляет несколько конструкций для перехвата исключений:

- **try ... catch**: Этот блок позволяет перехватывать исключения, возникающие в коде, который находится внутри блока try. 
Через вызов функции `throw/1` можно прерывать выполнение с определённым значением, которое в дальнейшем будет передано в `catch` в качестве аргумента.

Пример:
```elixir
try do
   Enum.map([1, 2, 3], fn x ->
     if x == 2, do: throw(x)
   end)
 catch
   x -> "Caught: #{x}"
end

"Caught: 2"
```

- **try ... rescue**: Эта конструкция более подходит для обработки исключений, возникающих в ходе выполнения кода. 
При использовании rescue, следует указывать тип исключения, которое требуется перехватить, либо можно перехватить все исключения без сопоставления.

Пример 1:
```elixir
iex(1)>
defmodule Example do
  def divide(a, b) do
    try do
      a / b
    rescue
      ArithmeticError -> "Division by zero is not allowed."
    end
  end
end

iex(2)> Example.divide(10, 0)
"Division by zero is not allowed."
```

Пример 2:
```elixir
try do
  do_something()
rescue
  e in RuntimeError -> {:error, e.message}
  e in CodeError -> {:error, e.code, e.message}
  _ -> :error
end
```

## Использование after

Блок after можно использовать вместе с try, чтобы выполнить код, который всегда должен выполняться, независимо от того, произошло исключение или нет. 
Это может быть полезно для освобождения ресурсов или записи логов.

Пример:
```elixir
defmodule FileReader do
  def read(filepath) do
    try do
      do_something(filepath)
    rescue
      _ -> :error
    after
      File.rm(filepath)
    end
  end
end
```

Другой вариант применения блока `after` вне контекста исключений заключается в том, что можно выполнить код который будет выполнен после завершения основного блока функции.

Например:
```elixir
defmodule Int do
  def is_odd(val) do
    rem(val, 2) == 1
  after
    IO.inspect(val)
  end
end

iex(1)> result = Int.is_odd 11
11
true
iex(19)> result
true
```

Такой способ удобно использовать для выполнения различных каллбеков, завершений действий с файлами, логированием и прочее. 
При этом действие в блоке `after` не влияет на ответ функции (если конечно не будет выброшено исключение в этом блоке).

## Собственные исключения

Для создания собственного исключения в Elixir, необходимо определить модуль, который будет представлять собой исключение. 
Это можно сделать, используя функцию defexception, которая автоматически создает необходимые функции для работы с ошибками.

Пример:
```elixir
defmodule CustomError do
  defexception message: "Произошла ошибка"
end

iex(1)> raise CustomError, message: "ой, что-то пошло не так"
** (CustomError) ой, что-то пошло не так
```

Метод `raise` первым параметром принимает класс исключения, вторым ключевой список со значениями.
Чтобы использовать передачу аргументов, в модуле стоит определить функцию `exception`:

```elixir
defmodule CustomError do
  defexception message: "Произошла ошибка", code: nil

  def exception(code) do
    %CustomError{code: code}
  end
end

iex(2)> raise CustomError, 500
** (CustomError) Произошла ошибка
```

В данном примере можно теперь используя перехват, получить код ошибки:

```elixir
try do
...
rescue
  e in CustomError -> {:error, e.code, e.message}
end
```

## Рекомендации

* В Elixir принято соглашение, если функция выбрасывает исключение, ее имя должно заканчиваться восклицательным знаком. Например: `File.read!("data.csv")`
* Следует минимизировать использования исключений, вместо них стоит рассмотреть возможность использования конструкций, возвращающих ошибки, таких как {:error, reason}. Это сделает код более предсказуемым и упрощает обработку ошибок.
* Стоит знать так же функцию `exit` которая используется для отправки сигнала завершения (или "выхода") в процессах. 
Отправка такого сигнала может привести к немедленному завершению данного процесса, а также к завершению его дочерних процессов, в зависимости от используемой стратегии. 
При этом такие ошибки не будет перехвачены блоком `rescue` (только `catch`). Более подробное изучение данного функционала следует рассмотреть отдельно в контексте многопоточного программирования.

## Задание

> **ЗАДАНИЕ**. Реализовать модуль исключения `App.Error` в файле [App.Error](../lib/error.ex).
> В исключении требуется реализовать 2 поля: `message` (значение по умолчанию "Ошибка") и поле `value`.
> Реализовать логику вызова исключения с 1 параметром value, пример вызова: `raise App.Error, 18` 
> Реализовать логику вызова исключения с 2 параметрами value, message, переданных списоком. Пример вызова: `raise App.Error, [18, "Значение вызвало ошибку"]` 

> **Самопроверка**. Запустить команду `make verify` для проверки кода.
> Запустить тест модуля: `mix test test/error_test.exs`
